/*路径层：它可以理解为该对象在View的客户区中所占领的区域，在各自区域内可以进行作图、文字输出等，不受外界影响。

/*响应菜单项命令的顺序依次是：视类、文档类、框架类、最后是应用程序类
菜单命令消息路由的具体过程：
  当点击某个菜单项时，最先接收到这个菜单命令消息的是框架类。框架类将把接收到的这个消息交
给它的子窗口，即视类，由视类首先进行处理。视类首先根据命令消息映射机制查找自身是否对此消息进行了响应，如果响应了，
就调用相应响应函数对这个消息进行处理，消息路由过程结束。如果视类没有对此命令消息作出相应，就交由文档类，文档类同样
查找自身是否对这个菜单命令进行了响应，如果响应了，就由文档类的命令消息响应函数进行处理，消息路由过程接收。如果文档
类也未做出响应，就把这个命令消息还给视类，后者又把该消息交还给框架类。框架类查看自己是否对这个命令进行了响应，如果
它也没有做出响应，就把这个菜单命令消息交给应用程序类，由后者来处理。

/*在Windows中命令分三类：
1、命令消息
来自菜单、加速键或工具栏按钮的消息。这类消息都可以以WM_COMMAND形式呈现。在MFC中，通过菜单项的标识（ID）来区分
不同的命令消息：在SDK中，通过消息的wParam参数识别。从CCmdTarget派生来的类，都可以接收到这类消息。

2、标准消息
  除WM_COMMAND之外，所有以WM_开头的消息都是标准消息。从CWnd派生的类，都可以接收到这类消息。
  
3、通告消息
  由控件产生的消息，例如按钮的单击、列表框的选择等都会产生这类消息，目的是为了向其父窗口（通常是对话框）通知事件的
的发生。这类消息也是以WM_COMMAND形式呈现的。从CCmdTarget派生的类，都可以接收到这类消息。

/*如果想输入内容可以利用：
  CString str;
  str.Format("%d,%d",x,y);
  MessageBox(str);
  
/*MFC为菜单提供了一种命令更新的机制，所以，程序在运行时，根据此机制去判断哪个菜单可以使用，哪个菜单不能够使用，然后显示其相应的状态。
默认情况下，所有菜单项的更新都是由MFC的命令更新机制完成的。如果我们想自己更改菜单项的状态，那就必须先把m_bAutoMenuEnable变量设置为FALSE,
之后，我们自己对菜单项的状态更新才能起作用。因此，我们就在程序Menu的CMainFrame类构造函数中把m_bAutoMenuEnable这个变量初始化为FALSE

/*MFC命令更新机制：
  当要显示菜单时，操作系统发出WM_INITMENUPOPUP消息，然后由程序窗口的基类如CFrameWnd接管。它会创建一个CCmdUI对象，并与程序的第一个菜单项相关联，
调用该对象的一个成员函数DoUpdate()。这个函数发出CN_UPDATA_COMMAND_UI消息，这条消息带有一个指向CCmdUI对象的指针。这时，系统会判断是否存在一个
ON_UPDATE_COMMAND_UI宏去捕获这个菜单项消息。如果找到这样一个宏，就调用相应的消息响应函数进行处理，在这个函数中，可以利用传递过来的CCmdUI对象去调用相应
的函数，使该菜单项可以使用，或禁用该菜单项。当更新完第一个菜单项后，同一个CCmdUI对象就设置为第二个菜单项相关联，依此顺序进行，直到完成所有菜单项的处理。
