/*幂函数2^n算法
inline int sqr(int a){return a*a;}
int power2(int n){
    if(n==0) return 0;
    else
        return (n&1)?sqr(power2(n>>1))<<1:sqr(power2(n>>1));
    }

/*相较于同一算法的迭代版，递归版往往需耗费更多空间，并进而影响实际的运行速度。另外，就操作系统而言，为实现递归调用需要花费大量额外的时间以创建、维护和
销毁各递归实例，这些也会令计算的负担雪上加霜。在对运行速度要求极高、存储空间需精打细算的场合，往往将递归算法改写成等价的非递归版本。

/*系统在后台隐式维护调用栈的过程中，难以区分哪些变量和参数是对计算过程有实质作用的，更无法通过以通用的方式对其进行优化，因此不得不将描述调用现场的所有
变量和参数悉数入栈。再加上每一帧必须保存和执行的返回地址以及上一帧的初始位置，往往导致程序的空间效率不高甚至极低；同时，隐式的入栈和出栈时间也会令实际
运行时间增加很多。 因此在追求更高效率的场合，应当尽可能避免递归，尤其是过度递归。

/***********************************************表达式求值算法**********************************************************/
优先级表
我们首先如代码4.6所示，将不同运算符之间的运算优先级关系，描述为一张二维表格。
1 #define N_OPTR 9 //运算符总数
2 typedef enum {ADD, SUB, MUL, DIV, POW, FAC, L_P, R_P, EOE} Operator; //运算符集合
3 //加、减、乘、除、乘斱、阶乘、左括号、右括号、起始符不终止符
4
5 const char pri[N_OPTR][N_OPTR] = { //运算符优先等级 [栈顶] [弼前]
6 /* |-------------- 弼前运算符 --------------| */
7 /* + - * / ^ ! ( ) \0 */
8 /* -- + */ '>', '>', '<', '<', '<', '<', '<', '>', '>',
9 /* | - */ '>', '>', '<', '<', '<', '<', '<', '>', '>',
10 /* 栈 * */ '>', '>', '>', '>', '<', '<', '<', '>', '>',
11 /* 顶 / */ '>', '>', '>', '>', '<', '<', '<', '>', '>',
12 /* 运 ^ */ '>', '>', '>', '>', '>', '<', '<', '>', '>',
13 /* 算 ! */ '>', '>', '>', '>', '>', '>', ' ', '>', '>',
14 /* 符 ( */ '<', '<', '<', '<', '<', '<', '<', '=', ' ',
15 /* | ) */ ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ',
16 /* -- \0 */ '<', '<', '<', '<', '<', '<', '<', ' ', '='
17 };

float evaluate(char* s,char &RPN){
    Stack<float> opnd;  //储存操作数
    Stack<char> optr;   //储存运算符
    optr.push('\0');    //尾哨兵，也作为头哨兵首先入栈
    while(!optr.empty()){
        if(isDigit(*s)){
            readNumber(*s,opnd);    //将数值入栈
            append(RPN,opnd.top()); //接到RPN的末尾
        }
        else{   //是操作数
            switch(orderBetween(optr.top(),*s){
                case '<':   //栈顶运算符优先级小于当前运算符
                    optr.push(*s);
                    s++;
                    break;
                case '=':
                    optr.pop();     //当前元素为有括号或者是'\0'
                    s++;
                    break;
                case '>':   //当栈顶运算符优先级更高的时候，可实施相应的运算，并把结果入栈
                    char op=optr.pop();
                    append(RPN,op);
                    if(!==op){  //是一元运算符
                        float pOpnd=opnd.pop();
                        opnd.push(calcu(op,pOpnd));
                    }
                    else{
                        float pOpnd1=opnd.pop();
                        float pOpnd2=opnd.pop();
                        opnd.push(calcu(pOpnd1,op,pOpnd2);
                    }
                    break;
                    
                default:
                    exit(-1);
            }  
        }
    }
    return opnd.pop();  //返回最终结果
}
