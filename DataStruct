/*幂函数2^n算法
inline int sqr(int a){return a*a;}
int power2(int n){
    if(n==0) return 0;
    else
        return (n&1)?sqr(power2(n>>1))<<1:sqr(power2(n>>1));
    }

/*相较于同一算法的迭代版，递归版往往需耗费更多空间，并进而影响实际的运行速度。另外，就操作系统而言，为实现递归调用需要花费大量额外的时间以创建、维护和
销毁各递归实例，这些也会令计算的负担雪上加霜。在对运行速度要求极高、存储空间需精打细算的场合，往往将递归算法改写成等价的非递归版本。

/*系统在后台隐式维护调用栈的过程中，难以区分哪些变量和参数是对计算过程有实质作用的，更无法通过以通用的方式对其进行优化，因此不得不将描述调用现场的所有
变量和参数悉数入栈。再加上每一帧必须保存和执行的返回地址以及上一帧的初始位置，往往导致程序的空间效率不高甚至极低；同时，隐式的入栈和出栈时间也会令实际
运行时间增加很多。 因此在追求更高效率的场合，应当尽可能避免递归，尤其是过度递归。

/***********************************************表达式求值算法**********************************************************/
优先级表
我们首先如代码4.6所示，将不同运算符之间的运算优先级关系，描述为一张二维表格。
1 #define N_OPTR 9 //运算符总数
2 typedef enum {ADD, SUB, MUL, DIV, POW, FAC, L_P, R_P, EOE} Operator; //运算符集合
3 //加、减、乘、除、乘斱、阶乘、左括号、右括号、起始符不终止符
4
5 const char pri[N_OPTR][N_OPTR] = { //运算符优先等级 [栈顶] [弼前]
6 /* |-------------- 弼前运算符 --------------| */
7 /* + - * / ^ ! ( ) \0 */
8 /* -- + */ '>', '>', '<', '<', '<', '<', '<', '>', '>',
9 /* | - */ '>', '>', '<', '<', '<', '<', '<', '>', '>',
10 /* 栈 * */ '>', '>', '>', '>', '<', '<', '<', '>', '>',
11 /* 顶 / */ '>', '>', '>', '>', '<', '<', '<', '>', '>',
12 /* 运 ^ */ '>', '>', '>', '>', '>', '<', '<', '>', '>',
13 /* 算 ! */ '>', '>', '>', '>', '>', '>', ' ', '>', '>',
14 /* 符 ( */ '<', '<', '<', '<', '<', '<', '<', '=', ' ',
15 /* | ) */ ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ',
16 /* -- \0 */ '<', '<', '<', '<', '<', '<', '<', ' ', '='
17 };

float evaluate(char* s,char &RPN){
    Stack<float> opnd;  //储存操作数
    Stack<char> optr;   //储存运算符
    optr.push('\0');    //尾哨兵，也作为头哨兵首先入栈
    while(!optr.empty()){
        if(isDigit(*s)){
            readNumber(*s,opnd);    //将数值入栈
            append(RPN,opnd.top()); //接到RPN的末尾
        }
        else{   //是操作数
            switch(orderBetween(optr.top(),*s){
                case '<':   //栈顶运算符优先级小于当前运算符
                    optr.push(*s);
                    s++;
                    break;
                case '=':
                    optr.pop();     //当前元素为有括号或者是'\0'
                    s++;
                    break;
                case '>':   //当栈顶运算符优先级更高的时候，可实施相应的运算，并把结果入栈
                    char op=optr.pop();
                    append(RPN,op);
                    if(!==op){  //是一元运算符
                        float pOpnd=opnd.pop();
                        opnd.push(calcu(op,pOpnd));
                    }
                    else{
                        float pOpnd1=opnd.pop();
                        float pOpnd2=opnd.pop();
                        opnd.push(calcu(pOpnd1,op,pOpnd2);
                    }
                    break;
                    
                default:
                    exit(-1);
            }  
        }
    }
    return opnd.pop();  //返回最终结果
}

逆波兰表达式（后缀表达式）

求值算法
rpnEvaluation(expr){
    //输入RPN表达式expr（假定正确 ）
    //输出表达式求值结果
    引入栈，用以保存操作数
    while（表达式未扫描完毕）
    {
        从expr中读入下一元素X；
        if(x是操作数）
            入栈；
        else{//是运算符
            从栈中弹出运算符所需要的操作数的个数
            进行运算并入栈
        }
        }
    返回栈顶（也就是最终运算结果）；
    }
    
    
/***********************************************利用回溯算法求八皇后问题**************************************************/

struct Queen{
    int x,y;
    Queen(int xx=0,yy=0):x(xx),y(yy){}
    
    bool operator ==(Queen const& q){
        return(x==q.x)||(y==q.y)||(x+y==q.x+q.y)||(x-y==q.x-q.y);
    }
    bool operator !=(Queen const& q){
        return !(*this==q);
    }
}
//将同行同列同一对角线视为相等

void placeQueen(int n){ //n皇后
    Stack<Queen> solution;
    Queen q(0,0);
    do{
        if(solution.size()>=N||q.y>=N) { //若已出界回溯上一行
            q=solution.pop();
            q.y++;
        }
        else{
            while((q.y<N)&&(solution.find(q)>=0){
                q.y++;
            }
            if(q.y<N){
                solution.push(q);
                if(solution.size()>=N)
                    nSolution++;
                q.x++;
                q.y=0;
            }
        }
    }while((0<q.x)||(q.y<N));
}

/****************************************************二叉树*************************************************************************/
前缀无歧义编码（prefix-free-code简称PFC）： 各字符的编码串互不为前缀，即便出现无法编码的情况也不会导致歧义

