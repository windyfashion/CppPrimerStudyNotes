/*在所有类说明中内部定义的成员都是内联函数
使用内联函数的地方会在 编译 阶段用内联函数体替换掉

/*1、内联函数的函数体不得含有复杂的结构控制语句，如switch、while和for。否则编译器将该函数视同普通函数那样产生函数调用代码。
2、递归函数不能被用来作为内联函数
3、内联函数一般只适用于1-5行语句的小函数，对于含有很多语句的大函数，一般没有必要用内联函数实现。
4、内联定义必须出现第一次调用内联函数之前
5、对内联函数不能进行异常接口声明，就是不能声明可能抛出的异常。 

/*斐波那契数列数列从第3项开始，每一项都等于前两项之和。

例子：数列 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233，377，610，987，1597，2584，4181，6765，10946，17711，28657，46368........

/*负数以补码存储，形式为源码按位取反后加1；正数的补码是自己

/*int fseek(FILE *stream,long offset,int fromwhere) 函数设置文件指针stream的位置
如果执行成功，stream将指向以fromwhere为基准，偏移offset个字节的位置，函数返回0.如果执行失败，则不改变stream指向的位置，函数返回一个值

/*在一个16位机器，以下结构由于边界对齐浪费了多少空间
struct{
  char a;
  int b;
  char c;
}
结构体中字节对齐有两条规则：
1、数据成员自对齐，即数据成员起始地址为数据类型长度的整数倍，如该题int型b只能从0,2,4....等地址开始放
2、结构体总长度是结构体中有效对齐值的正数倍，有效对齐值，如没明确指出，则为最长数据成员的长度整数倍
根据规则1，int b从2处开始放，此时结构体的长度为1+1+2+1=5；再根据规则2，结构体总长度应为2的正数倍故应为6，因此有两个字节被浪费

/*数组名不能赋值包括自增和自减

/*没用参数的两个函数是不能进行重载的，说法是否正确？  错误
1、c++不允许仅根据函数的返回类型重载函数名称
2、可以编写两个名字相同，参数也相同的函数，其中一个是const 一个是非const

/*
class A{
    public:
     ~A();
}:
A::~A(){
    printf("delete A");
}

class B{
    public:
    ~B();
}

B::~B{
    printf("delete B");
}

执行以下代码：
A *pa=new B();
delete pa;

输出字符串 delete A


析构函数做最后的清场工作，一般来说当派生类对象从内存中撤销时，先调用派生类析构函数，再调用基类析构函数；
但若使用new建立了临时对象（基类指针指向临时对象），在用delete撤销对象时，系统会只执行基类的析构函数，而不执行派生类的析构函数
如果基类将析构函数声明为虚函数，由基类所有派生类的析构函数自动成为虚函数（即使析构函数名不同）。在运行阶段，先调用派生类析构，再调用基类析构

/*****在C语言中，以下代码执行之后，*p的值为（5）

void func(int *p)
{
    static int num = 4;
    p = &num;
    (*p)--;
}
int main()
{
    int i = 5;
    int *p = &i;
    func(p);
    printf("%d", *p);
    return 0;
}
尽管函数的形参是指针，但是注意，它仍然是“值传递”。
一方面，函数本身没有任何返回；另一方面，函数只是对p的值的处理，并非p的地址。
函数调用时，p作实参，函数中也给p重新赋值，函数确实使静态局部变量num的值减1，但是函数执行完，返回到主函数中，p中的仍然是i的地址。
若要使得p指向num，需要对p的地址进行传递，此时： 

/*若全局变量仅在单个C文件中访问，则可以将这个变量修改为静态全局变量，以降低模块间的耦合度
若全局变量仅由单个函数访问，则可以将这个变量改为该函数的静态局部变量，以降低模块间的耦合度
设计和使用访问动态全局变量、静态全局变量、静态局部变量的函数时，需要考虑重入问题

重入和不可重入
这种情况出现在多任务系统当中，在任务执行期间捕捉到 信号 并对其进行处理时，进程正在执行的指令序列就被信号处理程序临时 中断 。
如果从信号处理程序返回，则继续执行进程断点处的正常指令序列，从重新恢复到断点重新执行的过程中，函数所依赖的环境没有发生改变，
就说这个函数是 可重入 的，反之就是 不可重入 的。
满足下面条件之一的多数是不可重入函数：
(1)使用了静态数据结构;
(2)调用了malloc或free;
(3)调用了标准I/O函数;标准io库很多实现都以不可重入的方式使用全局数据结构。
(4)进行了浮点运算.许多的处理器/编译器中，浮点一般都是不可重入的 (浮点运算大多使用协处理器或者软件模拟来实现。

/*
scanf函数完全就是字符串匹配而已啦。
如果你这么写，scanf("%d %d %d",&m,&n,&p);那么输入就应该是123 456 789；
如果写成scanf("%d,%d,%d",&m,&n,&p);那么输入就应该是123,456,789。
字符串一个一个的匹配，匹配到%d时，就自动把数值赋给右边的参数..

/* gets()函数从终端输入一个字符串到数组，直到按回车键为止，并把回车键保存为'\0'

/*
C语言标准库函数strcpy，把从src地址开始且含有'\0'结束符的字符串复制到以dest开始的 地址空间。。
从a[1]的地址开始，把b[2]开始的字符复制到a[1]，当然字符串结束标志也复制过去了。此时a[10] = "a2\0";
strcat( a,c+1);这个就简单多了。把c[1]开始的字符串接过去到a的屁股后面。。a[10]="a2yz\0";

-------------------------------------------------------2018.12.18--------------------------------------------------------------------

/c语言最简单的类型：整型、实型、字符型。c语言中没有bool型

/*project中每个cpp经编译成为obj（object）文件，所有obj文件经链接(link)成为可执行文件。所以obj可称为目标文件或中间文件。 

/*C++语言中，对于基类型相同的两个指针变量之间可以进行大小比较、赋值及
减法运算，但加法运算没有意义。所以应选择C。 

/*下面程序的输出是（）
class A
{
public:
    void foo()
    {
        printf("1");
    }
    virtual void fun()
    {
        printf("2");
    }
};
class B: public A
{
public:
    void foo()
    {
        printf("3");
    }
    void fun()
    {
        printf("4");
    }
};
int main(void)
{
    A a;
    B b;
    A *p = &a;
    p->foo();
    p->fun();
    p = &b;
    p->foo();
    p->fun();
    A *ptr = (A *)&b;
    ptr->foo();
        ptr->fun();
    return 0;
}
 1，首先声明为A类型的指针指向实际类型为A的对象，调用的肯定是A的方法，输出1 2,
2，然后声明为A类型的指针指向实际类型为B的对象，则非虚函数调用A的方法，输出1，虚函数调用实际类型B的方法，输出4
3，声明类型为A的指针指向实际类型为B的对象，进行一个强制类型转换，其实这种父类指针指向子类会自动进行类型转换，所以是否强制类型转换都不影响结构，
原理同上一步，结果输出1 4
所以最终输出为121414


/* “子类”和“子类型”是不同的，替换原则只适合于"子类型"关系，而一般编程语言只是考虑了"子类"关系，
子类 : 说明了新类是继承自父类
子类型 : 强调的是新类具有父类一样的行为（未必是继承）。
那么，什么时候才应该使用继承？  那就是符合子类型关系的时候，或者一般所说的”is a"关系， 你必须保证新类的行为与父类完全一致！！！
在任何使用父类的场合，新类应该表现一样的行为。
链接：https://www.nowcoder.com/questionTerminal/81c3e33a2f834b168487c22e85a85b0f
来源：牛客网

/*C++规定构造函数不能是虚函数，而析构函数可以是虚函数。 这样死记硬背也是一种办法，但是不推荐。
可以这么理解，这实际也是一道常见的面试题。
假设构造函数为虚函数，而虚函数的调用需要虚表，虚表又由构造函数建立。
这样就矛盾了。  就像儿子生了父亲一样，矛盾。
所以，构造函数不能是虚函数。

/*C++标准规定类的大小不为0，空类的大小为1，当类不包含虚函数和非静态数据成员时，其对象大小也为1，所以nLenA和nLenAObject的值为1； 
如果在类中声明了虚函数（不管是1个还是多个），那么在实例化对象时，编译器会自动在对象里安插一个指针指向虚函数表VTable，在32位机器上，
一个对象会增加4个字节来存储此指针，它是实现面向对象中多态的关键。因此，LenB和nLenBObject的值为4；
 对于普通继承，派生类和基类共享虚函数指针，派生类对象的存储空间=基类存储空间+派生类特有的非static数据成员的空间，
 由于t_classA为空类，t_classB和t_classC共享虚函数指针，因此LenC和nLenCObject的值为4； 
