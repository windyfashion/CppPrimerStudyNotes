/*在所有类说明中内部定义的成员都是内联函数
使用内联函数的地方会在 编译 阶段用内联函数体替换掉

/*负数以补码存储，形式为源码按位取反后加1；正数的补码是自己

/*int fseek(FILE *stream,long offset,int fromwhere) 函数设置文件指针stream的位置
如果执行成功，stream将指向以fromwhere为基准，偏移offset个字节的位置，函数返回0.如果执行失败，则不改变stream指向的位置，函数返回一个值

/*在一个16位机器，以下结构由于边界对齐浪费了多少空间
struct{
  char a;
  int b;
  char c;
}
结构体中字节对齐有两条规则：
1、数据成员自对齐，即数据成员起始地址为数据类型长度的整数倍，如该题int型b只能从0,2,4....等地址开始放
2、结构体总长度是结构体中有效对齐值的正数倍，有效对齐值，如没明确指出，则为最长数据成员的长度整数倍
根据规则1，int b从2处开始放，此时结构体的长度为1+1+2+1=5；再根据规则2，结构体总长度应为2的正数倍故应为6，因此有两个字节被浪费

/*数组名不能赋值包括自增和自减

/*没用参数的两个函数是不能进行重载的，说法是否正确？  错误
1、c++不允许仅根据函数的返回类型重载函数名称
2、可以编写两个名字相同，参数也相同的函数，其中一个是const 一个是非const

/*
class A{
    public:
     ~A();
}:
A::~A(){
    printf("delete A");
}

class B{
    public:
    ~B();
}

B::~B{
    printf("delete B");
}

执行以下代码：
A *pa=new B();
delete pa;

输出字符串 delete A


析构函数做最后的清场工作，一般来说当派生类对象从内存中撤销时，先调用派生类析构函数，再调用基类析构函数；
但若使用new建立了临时对象（基类指针指向临时对象），在用delete撤销对象时，系统会只执行基类的析构函数，而不执行派生类的析构函数
如果基类将析构函数声明为虚函数，由基类所有派生类的析构函数自动成为虚函数（即使析构函数名不同）。在运行阶段，先调用派生类析构，再调用基类析构

