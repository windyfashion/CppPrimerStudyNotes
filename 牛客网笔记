/*在所有类说明中内部定义的成员都是内联函数
使用内联函数的地方会在 编译 阶段用内联函数体替换掉

/*1、内联函数的函数体不得含有复杂的结构控制语句，如switch、while和for。否则编译器将该函数视同普通函数那样产生函数调用代码。
2、递归函数不能被用来作为内联函数
3、内联函数一般只适用于1-5行语句的小函数，对于含有很多语句的大函数，一般没有必要用内联函数实现。
4、内联定义必须出现第一次调用内联函数之前
5、对内联函数不能进行异常接口声明，就是不能声明可能抛出的异常。 

/*斐波那契数列数列从第3项开始，每一项都等于前两项之和。

例子：数列 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233，377，610，987，1597，2584，4181，6765，10946，17711，28657，46368........

/*负数以补码存储，形式为源码按位取反后加1；正数的补码是自己

/*int fseek(FILE *stream,long offset,int fromwhere) 函数设置文件指针stream的位置
如果执行成功，stream将指向以fromwhere为基准，偏移offset个字节的位置，函数返回0.如果执行失败，则不改变stream指向的位置，函数返回一个值

/*在一个16位机器，以下结构由于边界对齐浪费了多少空间
struct{
  char a;
  int b;
  char c;
}
结构体中字节对齐有两条规则：
1、数据成员自对齐，即数据成员起始地址为数据类型长度的整数倍，如该题int型b只能从0,2,4....等地址开始放
2、结构体总长度是结构体中有效对齐值的正数倍，有效对齐值，如没明确指出，则为最长数据成员的长度整数倍
根据规则1，int b从2处开始放，此时结构体的长度为1+1+2+1=5；再根据规则2，结构体总长度应为2的正数倍故应为6，因此有两个字节被浪费

/*数组名不能赋值包括自增和自减

/*没用参数的两个函数是不能进行重载的，说法是否正确？  错误
1、c++不允许仅根据函数的返回类型重载函数名称
2、可以编写两个名字相同，参数也相同的函数，其中一个是const 一个是非const

/*
class A{
    public:
     ~A();
}:
A::~A(){
    printf("delete A");
}

class B{
    public:
    ~B();
}

B::~B{
    printf("delete B");
}

执行以下代码：
A *pa=new B();
delete pa;

输出字符串 delete A


析构函数做最后的清场工作，一般来说当派生类对象从内存中撤销时，先调用派生类析构函数，再调用基类析构函数；
但若使用new建立了临时对象（基类指针指向临时对象），在用delete撤销对象时，系统会只执行基类的析构函数，而不执行派生类的析构函数
如果基类将析构函数声明为虚函数，由基类所有派生类的析构函数自动成为虚函数（即使析构函数名不同）。在运行阶段，先调用派生类析构，再调用基类析构

/*****在C语言中，以下代码执行之后，*p的值为（5）

void func(int *p)
{
    static int num = 4;
    p = &num;
    (*p)--;
}
int main()
{
    int i = 5;
    int *p = &i;
    func(p);
    printf("%d", *p);
    return 0;
}
尽管函数的形参是指针，但是注意，它仍然是“值传递”。
一方面，函数本身没有任何返回；另一方面，函数只是对p的值的处理，并非p的地址。
函数调用时，p作实参，函数中也给p重新赋值，函数确实使静态局部变量num的值减1，但是函数执行完，返回到主函数中，p中的仍然是i的地址。
若要使得p指向num，需要对p的地址进行传递，此时： 

/*若全局变量仅在单个C文件中访问，则可以将这个变量修改为静态全局变量，以降低模块间的耦合度
若全局变量仅由单个函数访问，则可以将这个变量改为该函数的静态局部变量，以降低模块间的耦合度
设计和使用访问动态全局变量、静态全局变量、静态局部变量的函数时，需要考虑重入问题

重入和不可重入
这种情况出现在多任务系统当中，在任务执行期间捕捉到 信号 并对其进行处理时，进程正在执行的指令序列就被信号处理程序临时 中断 。
如果从信号处理程序返回，则继续执行进程断点处的正常指令序列，从重新恢复到断点重新执行的过程中，函数所依赖的环境没有发生改变，
就说这个函数是 可重入 的，反之就是 不可重入 的。
满足下面条件之一的多数是不可重入函数：
(1)使用了静态数据结构;
(2)调用了malloc或free;
(3)调用了标准I/O函数;标准io库很多实现都以不可重入的方式使用全局数据结构。
(4)进行了浮点运算.许多的处理器/编译器中，浮点一般都是不可重入的 (浮点运算大多使用协处理器或者软件模拟来实现。

/*
scanf函数完全就是字符串匹配而已啦。
如果你这么写，scanf("%d %d %d",&m,&n,&p);那么输入就应该是123 456 789；
如果写成scanf("%d,%d,%d",&m,&n,&p);那么输入就应该是123,456,789。
字符串一个一个的匹配，匹配到%d时，就自动把数值赋给右边的参数..

/* gets()函数从终端输入一个字符串到数组，直到按回车键为止，并把回车键保存为'\0'

/*
C语言标准库函数strcpy，把从src地址开始且含有'\0'结束符的字符串复制到以dest开始的 地址空间。。
从a[1]的地址开始，把b[2]开始的字符复制到a[1]，当然字符串结束标志也复制过去了。此时a[10] = "a2\0";
strcat( a,c+1);这个就简单多了。把c[1]开始的字符串接过去到a的屁股后面。。a[10]="a2yz\0";

-------------------------------------------------------2018.12.18--------------------------------------------------------------------

/c语言最简单的类型：整型、实型、字符型。c语言中没有bool型

/*project中每个cpp经编译成为obj（object）文件，所有obj文件经链接(link)成为可执行文件。所以obj可称为目标文件或中间文件。 

/*C++语言中，对于基类型相同的两个指针变量之间可以进行大小比较、赋值及
减法运算，但加法运算没有意义。所以应选择C。 

/*下面程序的输出是（）
class A
{
public:
    void foo()
    {
        printf("1");
    }
    virtual void fun()
    {
        printf("2");
    }
};
class B: public A
{
public:
    void foo()
    {
        printf("3");
    }
    void fun()
    {
        printf("4");
    }
};
int main(void)
{
    A a;
    B b;
    A *p = &a;
    p->foo();
    p->fun();
    p = &b;
    p->foo();
    p->fun();
    A *ptr = (A *)&b;
    ptr->foo();
        ptr->fun();
    return 0;
}
 1，首先声明为A类型的指针指向实际类型为A的对象，调用的肯定是A的方法，输出1 2,
2，然后声明为A类型的指针指向实际类型为B的对象，则非虚函数调用A的方法，输出1，虚函数调用实际类型B的方法，输出4
3，声明类型为A的指针指向实际类型为B的对象，进行一个强制类型转换，其实这种父类指针指向子类会自动进行类型转换，所以是否强制类型转换都不影响结构，
原理同上一步，结果输出1 4
所以最终输出为121414


/* “子类”和“子类型”是不同的，替换原则只适合于"子类型"关系，而一般编程语言只是考虑了"子类"关系，
子类 : 说明了新类是继承自父类
子类型 : 强调的是新类具有父类一样的行为（未必是继承）。
那么，什么时候才应该使用继承？  那就是符合子类型关系的时候，或者一般所说的”is a"关系， 你必须保证新类的行为与父类完全一致！！！
在任何使用父类的场合，新类应该表现一样的行为。
链接：https://www.nowcoder.com/questionTerminal/81c3e33a2f834b168487c22e85a85b0f
来源：牛客网

/*C++规定构造函数不能是虚函数，而析构函数可以是虚函数。 这样死记硬背也是一种办法，但是不推荐。
可以这么理解，这实际也是一道常见的面试题。
假设构造函数为虚函数，而虚函数的调用需要虚表，虚表又由构造函数建立。
这样就矛盾了。  就像儿子生了父亲一样，矛盾。
所以，构造函数不能是虚函数。

/*C++标准规定类的大小不为0，空类的大小为1，当类不包含虚函数和非静态数据成员时，其对象大小也为1，所以nLenA和nLenAObject的值为1； 
如果在类中声明了虚函数（不管是1个还是多个），那么在实例化对象时，编译器会自动在对象里安插一个指针指向虚函数表VTable，在32位机器上，
一个对象会增加4个字节来存储此指针，它是实现面向对象中多态的关键。因此，LenB和nLenBObject的值为4；
 对于普通继承，派生类和基类共享虚函数指针，派生类对象的存储空间=基类存储空间+派生类特有的非static数据成员的空间，
 由于t_classA为空类，t_classB和t_classC共享虚函数指针，因此LenC和nLenCObject的值为4； 


/* 重载：
    只有在 同一类定义中的同名成员函数才存在重载关系 ，主要特点是 函数的参数类型和数目有所不同 ，但 不能出现函数参数的个数和类型均相同 ，
    仅仅依靠返回值类型不同来区分的函数，这和普通函数的重载是完全一致的。另外，重载和成员函数是否是虚函数无关

覆盖：
    在派生类中覆盖基类中的同名函数，要求两个函数的参数个数、参数类型、返回类型都相同，且基类函数必须是虚函数。

隐藏：
  派生类中的函数屏蔽了基类中的同名函数，
2个函数参数相同，但基类函数不是虚函数（和覆盖的区别在于基类函数是否是虚函数）。2个函数参数不同，无论基类函数是否是虚函数，
基类函数都会被屏蔽（和重载的区别在于两个函数不在同一类中）。 

/*scanf ：当遇到回车，空格和tab键会自动在字符串后面添加'\0'，但是回车，空格和tab键仍会留在输入的缓冲区中。
 
gets(): 以回车结束读取，使用'\0'结尾.回车符'\n'被舍弃没有遗留在缓冲区。可以用来输入带空格的字符串。

/* 构造函数的执行先执行父类，再执行子类。析构顺序想反

A B的析构函数不是虚函数，所以不会执行子类的虚函数。  

/*字符串"Hello"会被输出几次?
  int main() {
   printf("Hello");
   fork();
   printf("Hello");
  }
  
1.fork()函数会把它所在语句以后的语句复制到一个子进程里，单独执行。
2.如果printf函数最后没有"\n"，则输出缓冲区不会被立即清空，而fork函数会把输出缓冲区里的内容也都复制到子进程里。
所以，父进程和子进程各输出2个Hello，共4个。
如果第一个printf("Hello");写成printf("Hello\n");，则只会输出3个Hello，父进程2个，子进程1个。 

/*#define SIZE_20M (20*1024*1024)
void func_a()
{
    char *temp = malloc(SIZE_20M)
    return;
}
void func_b()
{
    char temp[SIZE_20M];
    //...do something using temp
    return;
}


A func_a 获得临时内存的方式效率通常更高。

B func_b 使用了太多的栈，程序可能会在运行时候崩溃。

C func_b 存在内存泄露

D func_a 和func_b 分配的内存会自动初始化0
答案为B
A   func_a()动态分配的数据位于堆区，func_b()的temp位于栈区，栈区的执行效率高于堆区，故func_b()效率高
C  func_b()中没有动态分配的内存，不存在泄露问题
D  都不会自动初始化为0，只有全局变量或者static变量会初始化为0
B  栈的空间一般为2M，分配太多栈空间程序肯定会崩溃 

/*volatile提醒编译器它后面所定义的变量随时都有可能改变 ，因此编译后的程序每次需要存储或读取这个变量的时候 ，都会直接从变量地址中读取数据。
如果没有volatile关键字，则编译器可能优化读取和存储，可能暂时使用寄存器中的值，如果这个变量由别的程序更新了的话，将出现不一致的现象。 

