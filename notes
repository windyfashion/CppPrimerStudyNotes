/*指向常量的指针，不能用于改变其所指对象的值。常量只能用指向常量的指针；而指向常量的指针可以指向非常量*/

/*函数体内定义的变量一般来说并非存放在固定地址当中，因此constexptr指针不能指向这样的变量。相反的，定义于所有函数体之外的对象，其地址固定不变，能用来
初始化constexptr指针。另外允许函数定义一类有效范围超过自身的变量，这类变量也有固定地址，因此可被constexptr绑定。*/

/*constexptr仅对指针有效（若用constexptr声明并定义了一个指针），与指针所指对象无关
    const int *p=nullptr; //底层const
    constexptr int *p = nullptr; //顶层const；
*/

/*typedef char * pstring;
  const pstring cstr=0;  //cstr是指向char的常量指针
  const pstring *ps;  //ps是一个指针 它的对象是指向char的常量指针
  const char *cstr=0;  //cstr是指向const char 的指针
  const 是对给定类型的修饰
  前者 const pstring cstr=0;可意为 const (char *) csptr;
  后者 const char *cstr=0; 可意为 (const char ) * csptr;
*/

/*使用auto声明多个变量时，所有变量的初始基本类型都必须一样*/

/*auto一般会忽略顶层const,但设置一个类型为auto的引用时，初始值中的顶层const仍然保留*/

/***********************deltype类型指示符*************************/
decltype 作用是选择并返回操作数的数据类型。在此过程中，编译器分析表达式并得到它的类型，却不实际计算表达式的值

decltype 处理顶层const时，如果decltype使用的表达式是一个变量，则返回该变量的类型（包括顶层const和引用在内）

decltype处理的表达式内容是解引用操作，则decltype的结果类型与表达式形式密切相关。

decltype所用表达式，如果变量名加上了一对括号的变量名，这样的decltype就会得到引用类型
int i=42;
decltype((i)) d;  //错误：d是int&,必须初始化
decltype(i) e;  //正确：e是一个（未初始化的）int

/***************************************Vector*******************************************/
/*如果循环体内部包含有向vector对象添加元素的语句，则不能使用范围for循环

/*但凡是使用了迭代器的循环体，都不要向迭代器所属的容器添加元素

/*不允许用auto关键字由初始值列表来推断类型

/*不存在引用数组和vector

/*如果两个指针分别指向不相关的对象，则不能比较它们

/*对于那些没有指定执行顺序的运算符来说，如果表达式指向并修改了同一个对象，将会引发错误，并产生未定义的行为
int i=0;
cout<<i<<""<<++i<<endl;  //未定义
因为<<运算符没有指定执行顺序，编译器有可能先求i的值再求++i的值，也有可能先求++i的值，再求i的值

有四种运算符明确指定了运算顺序：逻辑与(&&) 逻辑或(||) 条件(?:)  逗号(,)
/*bool类型 非0即真

/*不能通过范围for语句增加Vector对象的元素，因为在范围for语句中，预存了end()的值。

/*******************************************函数**********************************************/
/*return的作用是：终止当前正在执行的函数并将控制权返回到调用该函数的地方

/*不要返回局部对象的引用或者指针

/*重载的时候一个拥有顶层const的形参无法和另一个没有顶层const的形参区分开来

/*一般来说，将函数声明置于局部作用域内不是一个明智的选择。

/*如果我们在内层作用域中声明名字，它将隐藏外层作用域中声明的同名实体。在不同的作用域中无法重载函数名

/*含有多个形参的函数匹配，编译器选择那些形参数量满足要求且实参类型和形参类型能够匹配的函数。然后依次检查每个实参以确定哪个函数是最佳匹配。如果有且只有
一个函数满足下列条件，则匹配成功：
（1）该函数每个实参的匹配都不劣于其他可行函数需要的匹配
（2）至少有一个实参的匹配优于其他可行函数提供的匹配
如果在检查了所有的实参以后没有任何一个函数脱颖而出，则该调用是错误的。编译器将报告二义性错误

/*如果我们想定义一个返回数组指针的函数，则数组的维度必须跟在函数的名字之后。然而，函数的形参列表也跟在函数名字后面
且形参列表应该先于数组的维度

/*类的基本思想是数据抽象和封装。数据抽象是一种依赖于接口和实现分离的编程技术。类的接口包括用户所能执行的操作；
类的实现则包括类的数据成员、负责接口实现的函数体以及定义类所需的各种私有函数。
封装实现了类的接口和实现的分离。封装后的类隐藏了它的实现细节，也就是说，类的用户只能使用接口而无法访问实现部分。

/*std::string isbn() const{return bookNo;}
total.isbn();
当我们调用成员函数时，实际上是替某个对象调用它，如果isbn指向Salas_data的成员(例如bookNo),则它隐式地指向调用该函数对象的成员。在上面所示调用中
当isbn返回bookNo时，实际上它隐式的返回total.bookNo

/*默认情况下，this的类型是指向类类型非常量版本的常量指针。尽管this是隐式的，但它仍然需要遵循初始化规则，意味着我们不能把它绑定到一个常量对象
上。这一情况也就使我们不能在一个常量对象上调用普通的成员函数
this是隐式的并且不会出现在参数列表中，所以在哪儿将this声明成指向常量的指针就成为我们必须面对的问题。c++的做法是允许把const关键字放在成员函数的
参数列表之后，此时，紧跟在参数列表后面的const表示this是一个指向常量的指针。像这样使用const的成员函数被称作常成员函数

/*编译器分两步处理类：首先编译成员的声明，然后才轮到成员函数体

/*
