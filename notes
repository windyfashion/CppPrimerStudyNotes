/*指向常量的指针，不能用于改变其所指对象的值。常量只能用指向常量的指针；而指向常量的指针可以指向非常量*/

/*函数体内定义的变量一般来说并非存放在固定地址当中，因此constexptr指针不能指向这样的变量。相反的，定义于所有函数体之外的对象，其地址固定不变，能用来
初始化constexptr指针。另外允许函数定义一类有效范围超过自身的变量，这类变量也有固定地址，因此可被constexptr绑定。*/

/*constexptr仅对指针有效（若用constexptr声明并定义了一个指针），与指针所指对象无关
    const int *p=nullptr; //底层const
    constexptr int *p = nullptr; //顶层const；
*/

/*typedef char * pstring;
  const pstring cstr=0;  //cstr是指向char的常量指针
  const pstring *ps;  //ps是一个指针 它的对象是指向char的常量指针
  const char *cstr=0;  //cstr是指向const char 的指针
  const 是对给定类型的修饰
  前者 const pstring cstr=0;可意为 const (char *) csptr;
  后者 const char *cstr=0; 可意为 (const char ) * csptr;
*/

/*使用auto声明多个变量时，所有变量的初始基本类型都必须一样*/

/*auto一般会忽略顶层const,但设置一个类型为auto的引用时，初始值中的顶层const仍然保留*/

/***********************deltype类型指示符*************************/
decltype 作用是选择并返回操作数的数据类型。在此过程中，编译器分析表达式并得到它的类型，却不实际计算表达式的值

decltype 处理顶层const时，如果decltype使用的表达式是一个变量，则返回该变量的类型（包括顶层const和引用在内）

decltype处理的表达式内容是解引用操作，则decltype的结果类型与表达式形式密切相关。

decltype所用表达式，如果变量名加上了一对括号的变量名，这样的decltype就会得到引用类型
int i=42;
decltype((i)) d;  //错误：d是int&,必须初始化
decltype(i) e;  //正确：e是一个（未初始化的）int

/***************************************Vector*******************************************/
/*如果循环体内部包含有向vector对象添加元素的语句，则不能使用范围for循环

/*但凡是使用了迭代器的循环体，都不要向迭代器所属的容器添加元素

/*不允许用auto关键字由初始值列表来推断类型

/*不存在引用数组和vector

/*如果两个指针分别指向不相关的对象，则不能比较它们

/*对于那些没有指定执行顺序的运算符来说，如果表达式指向并修改了同一个对象，将会引发错误，并产生未定义的行为
int i=0;
cout<<i<<""<<++i<<endl;  //未定义
因为<<运算符没有指定执行顺序，编译器有可能先求i的值再求++i的值，也有可能先求++i的值，再求i的值

有四种运算符明确指定了运算顺序：逻辑与(&&) 逻辑或(||) 条件(?:)  逗号(,)
/*bool类型 非0即真

/*不能通过范围for语句增加Vector对象的元素，因为在范围for语句中，预存了end()的值。

/*******************************************函数**********************************************/
/*return的作用是：终止当前正在执行的函数并将控制权返回到调用该函数的地方

/*不要返回局部对象的引用或者指针

/*重载的时候一个拥有顶层const的形参无法和另一个没有顶层const的形参区分开来

/*一般来说，将函数声明置于局部作用域内不是一个明智的选择。

/*如果我们在内层作用域中声明名字，它将隐藏外层作用域中声明的同名实体。在不同的作用域中无法重载函数名

/*含有多个形参的函数匹配，编译器选择那些形参数量满足要求且实参类型和形参类型能够匹配的函数。然后依次检查每个实参以确定哪个函数是最佳匹配。如果有且只有
一个函数满足下列条件，则匹配成功：
（1）该函数每个实参的匹配都不劣于其他可行函数需要的匹配
（2）至少有一个实参的匹配优于其他可行函数提供的匹配
如果在检查了所有的实参以后没有任何一个函数脱颖而出，则该调用是错误的。编译器将报告二义性错误

/*如果我们想定义一个返回数组指针的函数，则数组的维度必须跟在函数的名字之后。然而，函数的形参列表也跟在函数名字后面
且形参列表应该先于数组的维度
