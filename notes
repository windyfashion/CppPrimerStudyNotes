/*指向常量的指针，不能用于改变其所指对象的值。常量只能用指向常量的指针；而指向常量的指针可以指向非常量*/

/*函数体内定义的变量一般来说并非存放在固定地址当中，因此constexptr指针不能指向这样的变量。相反的，定义于所有函数体之外的对象，其地址固定不变，能用来
初始化constexptr指针。另外允许函数定义一类有效范围超过自身的变量，这类变量也有固定地址，因此可被constexptr绑定。*/

/*constexptr仅对指针有效（若用constexptr声明并定义了一个指针），与指针所指对象无关
    const int *p=nullptr; //底层const
    constexptr int *p = nullptr; //顶层const；
*/

/*typedef char * pstring;
  const pstring cstr=0;  //cstr是指向char的常量指针
  const pstring *ps;  //ps是一个指针 它的对象是指向char的常量指针
  const char *cstr=0;  //cstr是指向const char 的指针
  const 是对给定类型的修饰
  前者 const pstring cstr=0;可意为 const (char *) csptr;
  后者 const char *cstr=0; 可意为 (const char ) * csptr;
*/

/*使用auto声明多个变量时，所有变量的初始基本类型都必须一样*/

/*auto一般会忽略顶层const,但设置一个类型为auto的引用时，初始值中的顶层const仍然保留*/

/***********************deltype类型指示符*************************/
decltype 作用是选择并返回操作数的数据类型。在此过程中，编译器分析表达式并得到它的类型，却不实际计算表达式的值

decltype 处理顶层const时，如果decltype使用的表达式是一个变量，则返回该变量的类型（包括顶层const和引用在内）

decltype处理的表达式内容是解引用操作，则decltype的结果类型与表达式形式密切相关。

decltype所用表达式，如果变量名加上了一对括号的变量名，这样的decltype就会得到引用类型
int i=42;
decltype((i)) d;  //错误：d是int&,必须初始化
decltype(i) e;  //正确：e是一个（未初始化的）int

/***************************************Vector*******************************************/
/*如果循环体内部包含有向vector对象添加元素的语句，则不能使用范围for循环

/*但凡是使用了迭代器的循环体，都不要向迭代器所属的容器添加元素

/*不允许用auto关键字由初始值列表来推断类型

/*不存在引用数组和vector

/*如果两个指针分别指向不相关的对象，则不能比较它们

/*对于那些没有指定执行顺序的运算符来说，如果表达式指向并修改了同一个对象，将会引发错误，并产生未定义的行为
int i=0;
cout<<i<<""<<++i<<endl;  //未定义
因为<<运算符没有指定执行顺序，编译器有可能先求i的值再求++i的值，也有可能先求++i的值，再求i的值

有四种运算符明确指定了运算顺序：逻辑与(&&) 逻辑或(||) 条件(?:)  逗号(,)
/*bool类型 非0即真

/*不能通过范围for语句增加Vector对象的元素，因为在范围for语句中，预存了end()的值。

/*******************************************函数**********************************************/
/*return的作用是：终止当前正在执行的函数并将控制权返回到调用该函数的地方

/*不要返回局部对象的引用或者指针

/*重载的时候一个拥有顶层const的形参无法和另一个没有顶层const的形参区分开来

/*一般来说，将函数声明置于局部作用域内不是一个明智的选择。

/*如果我们在内层作用域中声明名字，它将隐藏外层作用域中声明的同名实体。在不同的作用域中无法重载函数名

/*含有多个形参的函数匹配，编译器选择那些形参数量满足要求且实参类型和形参类型能够匹配的函数。然后依次检查每个实参以确定哪个函数是最佳匹配。如果有且只有
一个函数满足下列条件，则匹配成功：
（1）该函数每个实参的匹配都不劣于其他可行函数需要的匹配
（2）至少有一个实参的匹配优于其他可行函数提供的匹配
如果在检查了所有的实参以后没有任何一个函数脱颖而出，则该调用是错误的。编译器将报告二义性错误

/*如果我们想定义一个返回数组指针的函数，则数组的维度必须跟在函数的名字之后。然而，函数的形参列表也跟在函数名字后面
且形参列表应该先于数组的维度

/*类的基本思想是数据抽象和封装。数据抽象是一种依赖于接口和实现分离的编程技术。类的接口包括用户所能执行的操作；
类的实现则包括类的数据成员、负责接口实现的函数体以及定义类所需的各种私有函数。
封装实现了类的接口和实现的分离。封装后的类隐藏了它的实现细节，也就是说，类的用户只能使用接口而无法访问实现部分。

/*std::string isbn() const{return bookNo;}
total.isbn();
当我们调用成员函数时，实际上是替某个对象调用它，如果isbn指向Salas_data的成员(例如bookNo),则它隐式地指向调用该函数对象的成员。在上面所示调用中
当isbn返回bookNo时，实际上它隐式的返回total.bookNo

/*默认情况下，this的类型是指向类类型非常量版本的常量指针。尽管this是隐式的，但它仍然需要遵循初始化规则，意味着我们不能把它绑定到一个常量对象
上。这一情况也就使我们不能在一个常量对象上调用普通的成员函数
this是隐式的并且不会出现在参数列表中，所以在哪儿将this声明成指向常量的指针就成为我们必须面对的问题。c++的做法是允许把const关键字放在成员函数的
参数列表之后，此时，紧跟在参数列表后面的const表示this是一个指向常量的指针。像这样使用const的成员函数被称作常成员函数

/*编译器分两步处理类：首先编译成员的声明，然后才轮到成员函数体

/*类通过一个特殊的构造函数来控制默认初始化过程，这个函数叫做默认构造函数，默认构造函数无需任何实参。

/*编译器创建的构造函数又叫合成的默认构造函数，其将按如下规则初始化类的数据成员：
如果存在类内的初始值，用它来初始化成员
否则，默认初始化该成员

/*一旦我们定义了一些其他的构造函数，那么除非我们再定义一个默认的构造函数，否则类将没有默认构造函数

/*类可以允许其他类或者函数访问它的非公有成员，方法是令其他类或者函数成为他的友元

/*友元的声明只能出现在类定义的内部，但是在类内出现的具体位置不限。友元不是类的成员，也不受他所在区域访问控制级别的约束

/*一个const成员函数如果以引用的形式返回*this，那么它的返回类型将是常量引用

/*类和非成员函数的声明不是必须在它们的友元声明之前。当一个名字第一次出现在一个友元声明中时，我们隐式地假定该名字在当前作用于是可见的。
然而友元本身不一定真的声明在当前作用域当中。
甚至就算是在类的内部定义该函数，我们也必须在类的外部提供相应的声明从而使得函数可见。换句话说，即使我们仅仅是用声明友元的类的成员调用该友元函数，
它也必须是被声明过的：
struct X{
friend void f(){/*友元函数可以定义在类的内部*/}
X(){f();}       //错误f还没有被声明
void g();
void h();
};
void X::g(){return f();}        //错误：f还没有被声明
void f();       //声明f
void X::h(){return f();}        //正确：现在f()的声明已经在作用域当中了


/*一旦遇到了类名，定义的剩余部分就在类的作用域之内了，这里的剩余部分包括参数列表和函数体。

/*编译器处理完类中的全部声明后才会处理成员函数的定义

/*一般来说，内层作用域可以重新定义外层作用域中的名字，即使该名字已经在内层作用域中使用过。然而在类中，如果成员使用了外层作用域中的某个名字，
而该名字代表一种类型，则类不能在之后重新定义该名字。

/*在很多类当中，初始化和赋值的区别事关底层效率问题：前者直接初始化数据成员，后者则先初始化再赋值
除了效率之外更重要的是，一些数据成员必须被初始化

/*成员的初始化顺序与他们在类定义中的出现顺序一致：第一个成员先被初始化，然后第二个，以此类推。构造函数初始值列表中初始值的前后位置关系，不会影响
实际的初始化顺序
class X{
    int i;
    int j;
public:
    X(int val):j(val),i(j){}    //未定义：i在j之前初始化
};

/*当类中定义了其他构造函数的时候，最好也定义一下默认构造函数

/*给所有参数都提供默认值的函数，也是默认构造函数

/*如果构造函数只接受一个实参，则它实际上定义了转换为此类类型的隐式转换机制，有时我们把这种构造函数成为转换构造函数

/*在要求因式转换的程序上下文中，我们可以通过将构造函数声明为explicit加以阻止
关键字explicit只对一个实参的构造函数有效，需要多个实参的构造函数不能用于执行隐式转换，所有无须将这些构造函数指定为explicit的。
只能在类内声明构造函数时使用该关键字，在类外部定义时不应重复

/*explicit构造函数只能用于直接初始化

/*当一个类满足下面所有条件时，我们说它是聚合类：
1、所有的成员都是public的
2、没有定义任何构造函数
3、没有类内初始值
4、没有基类也没有virtual函数

/*数据成员都是字面值类型的聚合类是字面值常量类。如果一个类不是聚合类，但它满足下述要求，则它也是一个字面值常量类
1、数据成员都是字面值类型
2、类必须至少含有一个constexpr构造函数
3、如果一个数据成员含有类内初始值，则内置类型成员的初始值必须是一条常量表达式；或者如果成员属于某种类类型，
则初始值必须使用成员自己的constexpr构造函数
4类必须使用析构函数的默认定义，该成员负责销毁类的对象

/*1、类的静态成员：该成员只需与类的本身有关，而不是与类的对象有关，加上static关键字即可声明，其不与任何实例化对象绑定，
但是我们仍然可以使用类作用域运算符访问静态成员。
2、static声明在内部。在外部定义时，不加static.类似与一个全局变量，其初始值必须是常量表达式。
3、静态成员独立于任何对象，其类型可以是它所属的类类型。而非静态成员只能声明为其类的指针或引用
