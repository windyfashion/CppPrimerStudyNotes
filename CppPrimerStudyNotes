/*指向常量的指针，不能用于改变其所指对象的值。常量只能用指向常量的指针；而指向常量的指针可以指向非常量*/

/*函数体内定义的变量一般来说并非存放在固定地址当中，因此constexptr指针不能指向这样的变量。相反的，定义于所有函数体之外的对象，其地址固定不变，能用来
初始化constexptr指针。另外允许函数定义一类有效范围超过自身的变量，这类变量也有固定地址，因此可被constexptr绑定。*/

/*constexptr仅对指针有效（若用constexptr声明并定义了一个指针），与指针所指对象无关
    const int *p=nullptr; //底层const
    constexptr int *p = nullptr; //顶层const；
*/

/*typedef char * pstring;
  const pstring cstr=0;  //cstr是指向char的常量指针
  const pstring *ps;  //ps是一个指针 它的对象是指向char的常量指针
  const char *cstr=0;  //cstr是指向const char 的指针
  const 是对给定类型的修饰
  前者 const pstring cstr=0;可意为 const (char *) csptr;
  后者 const char *cstr=0; 可意为 (const char ) * csptr;
*/

/*使用auto声明多个变量时，所有变量的初始基本类型都必须一样*/

/*auto一般会忽略顶层const,但设置一个类型为auto的引用时，初始值中的顶层const仍然保留*/

/***********************deltype类型指示符*************************/
decltype 作用是选择并返回操作数的数据类型。在此过程中，编译器分析表达式并得到它的类型，却不实际计算表达式的值

decltype 处理顶层const时，如果decltype使用的表达式是一个变量，则返回该变量的类型（包括顶层const和引用在内）

decltype处理的表达式内容是解引用操作，则decltype的结果类型与表达式形式密切相关。

decltype所用表达式，如果变量名加上了一对括号的变量名，这样的decltype就会得到引用类型
int i=42;
decltype((i)) d;  //错误：d是int&,必须初始化
decltype(i) e;  //正确：e是一个（未初始化的）int

/***************************************Vector*******************************************/
/*如果循环体内部包含有向vector对象添加元素的语句，则不能使用范围for循环

/*但凡是使用了迭代器的循环体，都不要向迭代器所属的容器添加元素

/*不允许用auto关键字由初始值列表来推断类型

/*不存在引用数组和vector

/*如果两个指针分别指向不相关的对象，则不能比较它们

/*对于那些没有指定执行顺序的运算符来说，如果表达式指向并修改了同一个对象，将会引发错误，并产生未定义的行为
int i=0;
cout<<i<<""<<++i<<endl;  //未定义
因为<<运算符没有指定执行顺序，编译器有可能先求i的值再求++i的值，也有可能先求++i的值，再求i的值

有四种运算符明确指定了运算顺序：逻辑与(&&) 逻辑或(||) 条件(?:)  逗号(,)
/*bool类型 非0即真

/*不能通过范围for语句增加Vector对象的元素，因为在范围for语句中，预存了end()的值。

/*******************************************函数**********************************************/
/*return的作用是：终止当前正在执行的函数并将控制权返回到调用该函数的地方

/*不要返回局部对象的引用或者指针

/*重载的时候一个拥有顶层const的形参无法和另一个没有顶层const的形参区分开来

/*一般来说，将函数声明置于局部作用域内不是一个明智的选择。

/*如果我们在内层作用域中声明名字，它将隐藏外层作用域中声明的同名实体。在不同的作用域中无法重载函数名

/*含有多个形参的函数匹配，编译器选择那些形参数量满足要求且实参类型和形参类型能够匹配的函数。然后依次检查每个实参以确定哪个函数是最佳匹配。如果有且只有
一个函数满足下列条件，则匹配成功：
（1）该函数每个实参的匹配都不劣于其他可行函数需要的匹配
（2）至少有一个实参的匹配优于其他可行函数提供的匹配
如果在检查了所有的实参以后没有任何一个函数脱颖而出，则该调用是错误的。编译器将报告二义性错误

/*如果我们想定义一个返回数组指针的函数，则数组的维度必须跟在函数的名字之后。然而，函数的形参列表也跟在函数名字后面
且形参列表应该先于数组的维度

/*类的基本思想是数据抽象和封装。数据抽象是一种依赖于接口和实现分离的编程技术。类的接口包括用户所能执行的操作；
类的实现则包括类的数据成员、负责接口实现的函数体以及定义类所需的各种私有函数。
封装实现了类的接口和实现的分离。封装后的类隐藏了它的实现细节，也就是说，类的用户只能使用接口而无法访问实现部分。

/*std::string isbn() const{return bookNo;}
total.isbn();
当我们调用成员函数时，实际上是替某个对象调用它，如果isbn指向Salas_data的成员(例如bookNo),则它隐式地指向调用该函数对象的成员。在上面所示调用中
当isbn返回bookNo时，实际上它隐式的返回total.bookNo

/*默认情况下，this的类型是指向类类型非常量版本的常量指针。尽管this是隐式的，但它仍然需要遵循初始化规则，意味着我们不能把它绑定到一个常量对象
上。这一情况也就使我们不能在一个常量对象上调用普通的成员函数
this是隐式的并且不会出现在参数列表中，所以在哪儿将this声明成指向常量的指针就成为我们必须面对的问题。c++的做法是允许把const关键字放在成员函数的
参数列表之后，此时，紧跟在参数列表后面的const表示this是一个指向常量的指针。像这样使用const的成员函数被称作常成员函数

/*编译器分两步处理类：首先编译成员的声明，然后才轮到成员函数体

/*类通过一个特殊的构造函数来控制默认初始化过程，这个函数叫做默认构造函数，默认构造函数无需任何实参。

/*编译器创建的构造函数又叫合成的默认构造函数，其将按如下规则初始化类的数据成员：
如果存在类内的初始值，用它来初始化成员
否则，默认初始化该成员

/*一旦我们定义了一些其他的构造函数，那么除非我们再定义一个默认的构造函数，否则类将没有默认构造函数

/*类可以允许其他类或者函数访问它的非公有成员，方法是令其他类或者函数成为他的友元

/*友元的声明只能出现在类定义的内部，但是在类内出现的具体位置不限。友元不是类的成员，也不受他所在区域访问控制级别的约束

/*一个const成员函数如果以引用的形式返回*this，那么它的返回类型将是常量引用

/*类和非成员函数的声明不是必须在它们的友元声明之前。当一个名字第一次出现在一个友元声明中时，我们隐式地假定该名字在当前作用于是可见的。
然而友元本身不一定真的声明在当前作用域当中。
甚至就算是在类的内部定义该函数，我们也必须在类的外部提供相应的声明从而使得函数可见。换句话说，即使我们仅仅是用声明友元的类的成员调用该友元函数，
它也必须是被声明过的：
struct X{
friend void f(){/*友元函数可以定义在类的内部*/}
X(){f();}       //错误f还没有被声明
void g();
void h();
};
void X::g(){return f();}        //错误：f还没有被声明
void f();       //声明f
void X::h(){return f();}        //正确：现在f()的声明已经在作用域当中了


/*一旦遇到了类名，定义的剩余部分就在类的作用域之内了，这里的剩余部分包括参数列表和函数体。

/*编译器处理完类中的全部声明后才会处理成员函数的定义

/*一般来说，内层作用域可以重新定义外层作用域中的名字，即使该名字已经在内层作用域中使用过。然而在类中，如果成员使用了外层作用域中的某个名字，
而该名字代表一种类型，则类不能在之后重新定义该名字。

/*在很多类当中，初始化和赋值的区别事关底层效率问题：前者直接初始化数据成员，后者则先初始化再赋值
除了效率之外更重要的是，一些数据成员必须被初始化

/*成员的初始化顺序与他们在类定义中的出现顺序一致：第一个成员先被初始化，然后第二个，以此类推。构造函数初始值列表中初始值的前后位置关系，不会影响
实际的初始化顺序
class X{
    int i;
    int j;
public:
    X(int val):j(val),i(j){}    //未定义：i在j之前初始化
};

/*当类中定义了其他构造函数的时候，最好也定义一下默认构造函数

/*给所有参数都提供默认值的函数，也是默认构造函数

/*如果构造函数只接受一个实参，则它实际上定义了转换为此类类型的隐式转换机制，有时我们把这种构造函数成为转换构造函数

/*在要求因式转换的程序上下文中，我们可以通过将构造函数声明为explicit加以阻止
关键字explicit只对一个实参的构造函数有效，需要多个实参的构造函数不能用于执行隐式转换，所有无须将这些构造函数指定为explicit的。
只能在类内声明构造函数时使用该关键字，在类外部定义时不应重复

/*explicit构造函数只能用于直接初始化

/*当一个类满足下面所有条件时，我们说它是聚合类：
1、所有的成员都是public的
2、没有定义任何构造函数
3、没有类内初始值
4、没有基类也没有virtual函数

/*数据成员都是字面值类型的聚合类是字面值常量类。如果一个类不是聚合类，但它满足下述要求，则它也是一个字面值常量类
1、数据成员都是字面值类型
2、类必须至少含有一个constexpr构造函数
3、如果一个数据成员含有类内初始值，则内置类型成员的初始值必须是一条常量表达式；或者如果成员属于某种类类型，
则初始值必须使用成员自己的constexpr构造函数
4类必须使用析构函数的默认定义，该成员负责销毁类的对象

/*1、类的静态成员：该成员只需与类的本身有关，而不是与类的对象有关，加上static关键字即可声明，其不与任何实例化对象绑定，
但是我们仍然可以使用类作用域运算符访问静态成员。
2、static声明在内部。在外部定义时，不加static.类似与一个全局变量，其初始值必须是常量表达式。
3、静态成员独立于任何对象，其类型可以是它所属的类类型。而非静态成员只能声明为其类的指针或引用

/**********************************************************IO类***************************************************************/
/*IO对象无拷贝或赋值
进行IO操作通常以引用的方式传递和返回流。读写一个IO对象会改变其状态，因此传递和返回的引用不能是const

/*IO条件状态

/*缓冲区刷新的原因：
1、程序正常结束，作为main函数的return操作的一部分，缓冲刷新被执行
2、缓冲区满时，需要刷新缓冲，而后新的数据才能继续写入缓冲区
3、我们可以使用操纵符如endl来显示刷新缓冲区
4、在每个输出操作之后，我们可以用操纵符unitbuf设置流的内部状态，来清空缓冲区。默认情况下，对cerr是设置unitbuf的，因此写到cerr的内容都是立即刷新的
5、一个输出流可能被关联到另一个流。在这种情况下，当读写被关联的流时，关联到的流的缓冲区会被刷新。例如默认情况下，cin和cerr都被关联到cout。因此，读
cin或写cerr都会导致cout的缓冲区被刷新

/*关联输入和输出流
tie有两个重载版本：一个版本不带参数，返回指向输出流的指针。如果本对象当前关联到一个输出流，则返回这个流的指针，如果对象未关联到流，则返回空指针。
第二个版本接受一个指向ostream的指针，将自己关联到此ostream

/*文件模式
in      以读方式打开
out     以写方式打开
app     每次写操作前均定位到文件末尾
ate     打开文件后立即定位到文件末尾
trunc   截断文件
binary  以二进制方式进行IO

/**********************************************************顺序容器****************************************************************/

/*为了创建一个元素为另一个容器的拷贝，两个容器的类型及其类型必须匹配。不过，当传递迭代器参数来拷贝一个范围时，就不要求容器类型时相同的了。
而且新容器和原来容器中的元素类型也可以不同，只要将要拷贝的元素转换为要初始化的容器的元素类型即可

/*如果元素类型是内置类型或者具有默认构造函数的类类型，可以只为构造函数提供一个容器大小参数，如果元素类型没有默认构造函数，除了大小参数外，还必须指定
一个显式地元素初始值

/*赋值相关运算会导致指向左边容器内部的迭代器、引用和指针失效。而swap操作将容器内容交换不会导致指向容器的迭代器、引用和指针失效。

/*调用swap后，元素本身并未交换，swap只是交换了两个容器的内部数据结构

/*除array外，swap不对任何元素进行拷贝、删除或插入操作，因此可以保证在常数时间内完成

/*元素不会移动的事实意味着，除string外，指向容器的迭代器、引用和指针在swap操作后都不会失效。它们仍然指向swap操作之前所指向的那些元素。
但是在swap操作之后，这些元素已属于不同容器了。

/*与其他容器不同，swap两个array会真正交换它们的元素。因此交换两个array所需要的时间跟array的数目成正比

/*forward_list有自己专有版本的insert和emplace
forward_list 不支持push_back和emplace_back
vector和string不支持push_front和emplace_front

/*当我们用一个对象来初始化容器时，或将一个对象插入到容器中时，实际上放入到容器中的是对象值的一个拷贝，而不是对象本身。就像我们将对象传递给非引用参数
一样，容器中的元素与提供值得对象之间没有任何关联。

/*迭代器表示要拷贝的范围，不能指向与目的位置相同的容器

/*当我们调用一个emplace成员函数的时候，则是将参数传递给元素类型的构造函数

/*每个顺序容器都有一个front函数，除forward_list之外的所有顺序容器都有一个back成员函数。这两个操作分别返回首元素和尾元素的引用

/*forward_list有特殊版本的earse
forward_list不支持pop_back;vector和string不支持pop_front

/*在向容器添加元素后：
1、如果容器时vector或string，且存储空间被重新分配，则指向容器的迭代器、指针和引用都会失效。如果存储空间未重新分配，指向插入位置之前的元素的迭代器、
指针和引用仍然有效，但指向插入位置之元素的迭代器、指针和引用会失效
2、对于deque，插入到除首尾位置之外的任何位置都会导致迭代器、指针和引用失效。如果在首尾位置添加元素，迭代器会失效，但指向存在的元素的引用和指针不会
失效
3、对于list和forward_list，指向容器的迭代器、指针和引用仍然有效

/*list和forward_list的迭代器不支持自加大于等于2以上的操作，若需要执行这样的操作，可以用advance（*iterator,int）：迭代器偏移n

/*标准库实现者采用了可以减少容器空间重新分配次数的策略：不得不获取新的内存空间时，vector和string的实现通常会分配比新的空间需求更大的内存空间。
容器预留这些空间作为备用，可用来保存更多的新元素。这样，就不需要每次添加新元素都重新分配容器的内存空间了

/*只有当需要的内存空间超过当前容量时，reserve调用才会改变vector的容量。如果需求大小大于当前容量，reserve至少分配与需求一样大的内存空间。
如果需求大小小于或等于当前容量，reserve什么也不做。特别是，当需求大小小于当前容量，容器不会退回内存空间。因此在调用reserve之后，capacity将会大于或
等于传递给resize的参数

/*shrink_to_fit请将capcaity()减少为与size()相同大小。但调用shrink_to_fit只是一个请求，标准库并不保证退还内存。

/********************************************************泛型************************************************************************/

/*一般情况下算法并不直接操作容器，而是遍历由两个迭代器指定的一个元素范围来进行操作。

/*谓词是一个可调用的表达式，其返回结果是一个能用作条件的值。

/*尽量保持lambda的变量捕获简单化
如果我们捕获一个指针或者迭代器，或者采用引用捕获方式，就必须确保在lambda执行时，绑定到迭代器、指针或引用的对象仍然存在。而且，需要保证对象具有预期的
值。在lambda从创建到它执行的这段时间里，可能有代码改变绑定的对象的值。

/*默认情况下，对一个值被拷贝的变量lambda不会改变其值，如果我们希望改变一个被捕获的变量的值，就必须在参数列表首加上关键字mutable

/*当我们需要为一个lambda定义返回类型时，必须使用尾置返回类型

/**************************************************参数绑定*************************************************/

/*bind函数：调用bind函数的一般形式是 auto newCallable = bind(callable,arg_list)
其中，newCallable本身是一个可调用对象，arg_list是一个逗号分隔的参数列表，对应给定的callable的参数。即，当我们调用newCallable时会调用Callable，并
传递给它arg_list中的参数
    arg_list中的参数可能包含_n的名字，其中n是一个整数。这些参数是“占位符”，表示newCallable的参数，它们占据了传递给newCallable的参数的“位置”。
数值n表示生成的可调用对象中参数的位置：_1为newCallable的第一个参数,_2为第二个参数，以此类推。
_n定义在一个名为placeholders的命名空间中，而这个命名空间本身定义在std命名空间中，因此为了使用这些名字，两个明明空间都要写上。

/*函数ref返回一个对象，包含给定的引用，此对象是可以拷贝的。标准库中还有一个cref函数，生成一个保存const引用的类。与bind一样，函数ref和cref也定义在
头文件functional中

/*istream_iterator允许使用懒惰求值
当我们将一个istream_iterator绑定到一个流时，标准库并不保证迭代器立即从流中读取数据。具体实现可以推迟从流中读取数据，直到我们使用迭代器时才真正读取。
标准库中的实现所保证的是，在我们第一次解引用迭代器之前，从流中读取数据的操作已经完成了。对于大多数程序来说，立即读取还是推迟读取没什么差别。但是，如果
我们创建了一个istream_iterator，没有使用就销毁了，或者我们正在从两个不同对象同步读取同一个流，那么何时读取可能就很重要了。

/*算法命名规范
1、一些算法使用重载形式传递一个谓词
接受谓词参数来代替<或者==运算符的算法，以及那些不接受额外参数的算法，通常都是重载的函数
2、_if版本的算法
接受一个元素值的算法通常有另外一个不同名的（不是重载）版本，该版本接受一个谓词代替元素值。
3、区分拷贝元素的版本和不拷贝的版本
默认情况下重排元素的算法将重排后的元素写回给定的输入序列中。这些算法还提供另一个版本，将元素写到一个指定的输出目的位置。

/***********************************************************关联容器**************************************************************/

/*有序容器的关键字类型
关联容器对其关键字有一些限制，对于有序容器中的要求，关键字类型必须定义元素比较的方法

/*使用关键字类型的比较函数
用来组织一个容器中元素的操作的类型也是该容器类型的一部分，为了指定使用自定义的操作，必须在定义关联容器时提供此操作的类型。
在尖括号中出现的每个类型，就仅仅是一个类型而已。当我们创建一个容器（对象 ）时，才会以构造函数参数的形式提供真正的比较操作

/*比较类型函数应该是一种函数指针类型

/*如果一个函数要求返回一个pair。在新标准下，我们可以对返回值进行列表初始化
pair<string,int>    process(vector<string> &v){
if(!v.empty())
    return {v.back(),v.back.size()};
    else
    return pair<string,int>();  //隐式返回构造函数
}

/*一个关键字的value_type是一个pair，我们可以改变pair的值，但不能改变关键字成员的值
set迭代器是const的

/*关联容器erase 迭代器版本返回void  key_type版本返回删除的数量 当为0时表示删除的元素不存在



